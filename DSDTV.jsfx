desc:DSDTV

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

slider1:delta=0.82<0.7,0.9,0.001>delta

@init
marker = 0x050000;
mult = 2^23;
invmult = 2^-23;
toggle = 1;
commonSrate = 176400*16;
desiredSrate = 500000;
invdesired = 1/desiredSrate;
upsampling = commonSrate / srate; // ensure that this value is integer 
downsampling = commonSrate / desiredSrate; // this really ought to be close to an integer, but we can deal with it
invdown = desiredSrate / commonSrate;
invup = srate / commonSrate;

// graphics specific definitions/constants
pimult = $pi*2;
togglefreq = 2*$pi/srate*0.5;

// other constants (performance matters here!)
inv305 = 1/305;
invhpos = 1 / (32-3);
inv32 = 1/32;

// actual function to display graphics for each rendered sample in each line
function display() (
  toggle * 0.1 * cos(pimult*sqrt((hpos*hpos + vpos*vpos)));
  //0;
);

// run this for every DSD sample
function upsampled_code()
(
  // increment position, wrap around once it reaches the LCM of desiredSrate and commonSrate
  // TODO: magic number here!
  position = (position + 1) % 8820000000;
  // get last value of fractional
  prev = fractional;
  // time in seconds (wrapped every position upsampled samples)
  fractional = position * invdown;
  // wrapped represents the fraction of a sample in desired srate
  wrapped = fractional*invdesired;
  wrapped = wrapped-(0|wrapped);
  // when we go to the next sample in desired srate, and need to update blanking
  (fractional|0) - (prev|0) ? (
    int = (int+1) % 20000; // 312*32
    // count of complete horizontal lines
    hcount = 0|(int * inv32);
    // position in horizontal line
    hblank = int % 32;
    // always sync at the start of a line
    hblank == 0
      // longer sync for video frames
      || (hblank == 1 && 5 <= hcount && hcount < 310)
      || (hblank == 1 && 317 <= hcount && hcount < 622)
      // vsync
      || ((hcount < 315 && (hcount < 2 || hcount > 312) ) && hblank != 15 && hblank != 31)
      || (hcount == 2 && hblank < 15)
      || (hcount == 312 && hblank > 15 && hblank != 31) ? out_unf = -1 : out_unf = -0.7;
  );
  // calculate graphics, when in the right place
  // first field (305 out of 312 lines)
  5 <= hcount && hcount < 310 && (3 <= hblank && hblank < 31) ? (
    hpos = (wrapped + (hblank - 3)) * invhpos - 0.5;
    vpos = (hcount - 5.5) * inv305 - 0.5;
    out_unf = 0.2 + display();
  );
  // second field (305 out of 313 lines)
  317 <= hcount && hcount < 622 && (3 <= hblank && hblank < 31) ? (
    hpos = (wrapped + (hblank - 3)) * invhpos - 0.5;
    vpos = (hcount - 316.5) * inv305 - 0.5;
    out_unf = 0.2 + display();
  );
  avg += out_unf;
  out_unf_1 = (1+out_unf)*0.5;
  v1 = out_unf_1 - ret;
  out = out * delta + v1 * omdelta;
  ret = out > 0.5
)

@slider
omdelta = 1-delta;

@sample

// upsample to DSD frequency
total = 0;
avg = 0;
loop(upsampling,
  // generate a bit
  upsampled_code();
  // accumulate bit in total (MSB should be oldest bit)
  total *= 2;
  total += ret;
);

// toggle marker (8 MSB of 24 bits) between 05 and FA, like in https://dsd-guide.com/sites/default/files/white-papers/DoP_openStandard_1v1.pdf
marker != 0x050000 ? marker = 0x050000 : marker = 0xFA0000;

total = total | marker;

total&0x800000 ? total = -1-(total~0xffffff);

spl0 = spl1 = total * invmult;
c += 1;
